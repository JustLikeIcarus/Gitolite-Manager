/**
 * Configuration!
 */
var config = {
	dbuser : 'gitolite',
	dbpass : 'yourpass',
	dbname : 'gitolite',
	dbhost : 'localhost',
	gitolitepath : './gitolite-admin'
};

/**
 * Module dependencies.
 */
require.paths.push('/usr/local/lib/node_modules');

var express = require('express');
var dbClient = require('mysql').Client();
var exec = require('child_process').exec;
var fs = require('fs');
var md5 = function (encrypt) {
	return require('crypto').createHash('md5').update(encrypt).digest("hex");
};
var app = module.exports = express.createServer();
// Configuration

dbClient.host = config.dbhost;
dbClient.user = config.dbuser;
dbClient.password = config.dbpass;
dbClient.database = config.dbname;
dbClient.connect();

app.configure(function(){
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(express.cookieParser());
  app.use(express.session({ secret: 'ftuPw107fhq0oCbf0xPxW8km8dKYc1WZRF33QaWV' }));
  app.use(app.router);
  app.use(express.static(__dirname + '/public'));
});

app.configure('development', function(){
  app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); 
});

app.configure('production', function(){
  app.use(express.errorHandler()); 
});

/**
*EL PROGRAMA!
*/

function forEachSeries(arr, iterator, callback) {
    if (!arr.length) {
        return callback();
    }
    var completed = 0;
    var iterate = function () {
    	iterator(arr[completed], function (err) {
			if (err) {
    	        callback(err);
   	            callback = function () {};
    	    } else {
        	    completed += 1;
        	    if (completed === arr.length) {
                	callback();
         	   } else {
            	  	iterate();
               }
        	}
     	});
 	};
    iterate();
};

function generateGitoliteConf(colbac) {
	var result = "#Config file generated by Gitolite Manager\n#(https://github.com/warorface/Gitolite-Manager)\n";
	var processMembers = function (members, callback) {
		forEachSeries(members, function(item, calli) {
			if (item == "") {
				calli();
				return;
			}
			var memberquery;
			if (item.substr(0,1) == "@") {
				memberquery = "SELECT name FROM groups WHERE id = "+item.substr(1, item.length-1);
				if (item == "@all") {
					result = result + "  @all";
					calli();
					return;
				}
			} else {
				memberquery = "SELECT username FROM users WHERE id= "+item;
			}
			dbClient.query(memberquery, function(err, memres, fields) {
				//console.log(memberquery);
				//	console.log(memres);
				var membername = "";
				if (typeof memres[0].username == "undefined") {
					membername = "@"+memres[0].name;
				} else {
					membername = memres[0].username;
				}
				result = result + " " + membername;
				//console.log("\n\n"+result+"\n\n");
				calli();
			});
		}, function() {
			callback();
		});	
	}
	var querystr = "SELECT * FROM groups";
	//Generamos Grupos
	dbClient.query(querystr, function (err, res, fields) {
		if (err) {
			console.log(err);
			return;
		}
		forEachSeries(res, function(resi, callback) {
			result = result + "@" +resi.name + " =";
			
			//console.log(resi);
			processMembers(resi.members.split(","), function() {
				result = result + "\n";			
				callback();
			})				
		}, function() {
			//Generamos los repos
			var queryrepo = "SELECT * FROM repositories";
			dbClient.query(queryrepo, function (err, res, fields) {
				forEachSeries(res, function(repo, nextrepo) {
					result = result + "\n\n\trepo\t" + repo.name +'\n';
					
					var permissions = [{'tipo': 'R', 
										'mem': repo['R']}, 
										{'tipo': 'RW', 'mem': repo['RW'] }, {'tipo': 'RW+', 'mem': repo['RW+'] }];
					forEachSeries(permissions, function(permit, nextperm) {
						if (permit.mem != null){
							result = result + "\t\t"+permit.tipo+"\t = ";
						} else {
							permit.mem = "";
						}
						processMembers(permit.mem.split(","), function(){
							nextperm();
						});
						
					}, function(){
						nextrepo();
					});
					
						
				}, function() {
					colbac(result);
				});
			});
		});
		
	});
}
function Gitolitecommitandpush(message){
	exec('cd '+config.gitolitepath+'/ && git commit -m "' + message + '"', function (err, stdout, stderr) {
		if (err !== null) {
			console.log(err);
		}
		exec('cd '+config.gitolitepath+'/ && git push', function (err, stdout, stderr) {
			if (err !== null) {
   				console.log(err);
			}
			console.log("commited!");
		});
	});
}
// Routes

app.get('/', function(req, res){
	dbClient.query("SELECT id as 'value', username as 'name'  FROM users ORDER BY id", function(err, resq, fields){
		var usrs = resq;
		dbClient.query("SELECT CONCAT('@',id) as 'value', name  FROM groups ORDER BY id", function(err, resq, fields){
			var grps = resq;
			res.render('index', {
    			title: 'Gitolite Manager',
    			groups: grps,
    			users: usrs
  			});
		});
	});
});

app.post('/newrepo', function(req, res) {
	var errors = new Array();
	if (!req.body.name){
		errors.push("Name Required");
	}
	if (req.body.name.indexOf(' ') != -1) {
		errors.push("Spaces not allowed");
	}
	dbClient.query("SELECT * FROM repositories WHERE name = '"+req.body.name+"'", function(err, resqu, fields){
		if(resqu.length > 0) {
			errors.push("Repo already exists");
		}
		if(errors.length > 0) {
			res.render('errors', {
				title: 'Error Registro', 
				error_array: errors 
			});
			return;
		} else {
			dbClient.query("INSERT INTO repositories (`name`, `RW+`, `owners`) VALUES ('"+req.body.name+"', '"+req.body.owner+"', '"+req.body.owner+"')", function(err, resq, fields) {
				if (err) {
					throw err;
				}
				var confChanges = "Added Repository: "+req.body.name;
				generateGitoliteConf(function (result) {
   					console.log(result);
   					fs.writeFile(config.gitolitepath +'/conf/gitolite.conf', result, function (err) {
       					if (err) {
           					console.log('nooooo');
           					throw err;
       					}
        				console.log("Guardado Conf");
        				exec('cd '+config.gitolitepath+'/ && git add conf/gitolite.conf', function (err, stdout, stderr) {
           					if (err !== null) {
               					console.log(err);
           					}
           					console.log("Agregado al repo");
           					Gitolitecommitandpush(confChanges);
							res.send("Successfully added Repository: "+req.body.name, 200);
        				});
    				});
				});
			});
		}
	});
});

app.post('/newuser', function(req, res){
	//console.log(req.body);
	var errors = new Array();
	if (!req.body.name) {
		errors.push("Name Required");
	}
	if (!req.body.username) {
		errors.push("Username Required");
	}
	if (!req.body.email) {
		errors.push("Email Required");
	}
	if (!req.body.pass) {
		errors.push("Password Required");
	}
	if (!req.body.pass_conf) {
		errors.push("Please confirm password");
	}
	if (!req.body.pubkey) {
		errors.push("Please provide a SSH Public Key");
	} else if (req.body.pubkey.substr(0,7) !="ssh-rsa") {
		errors.push("SSH Key must begin with \"ssh-rsa\"");
	}
	if (req.body.pass !== req.body.pass_conf) {
		errors.push("Passwords do not match");
	}
	dbClient.query("SELECT * FROM users WHERE username ='"+req.body.username+"'", function(err, resq, fields){
		if(resq.length > 0) {
			errors.push("User exists");
		}
		dbClient.query("SELECT * FROM users WHERE email ='"+req.body.email+"'", function(err, resqu, fields) {
			if(resqu.length > 0) {
				errors.push("Email was already used.");
			}
			if(errors.length > 0) {
				res.render('errors', {
					title: 'Error Registro', 
					error_array: errors 
				});
				return;
			} else {
				fs.writeFile(config.gitolitepath+'/keydir/'+req.body.username+".pub", req.body.pubkey, function(err) {
					if (err !== null) {
						throw err;
					}
					console.log("Guardado pub key");
					var confChanges = "Added public key of user: "+req.body.username;
       				exec('cd '+config.gitolitepath+'/ && git add keydir/'+req.body.username+".pub"	, function (err, stdout, stderr) {
            			if (err !== null) {
               				console.log(err);
           				}
           				console.log("Agregada al repo");
           				Gitolitecommitandpush(confChanges);
					});
				});
				dbClient.query("INSERT INTO `users` (`name`, `username`, `password`, `email`) VALUES ('"+req.body.name+"', '"+req.body.username+"', '"+md5(req.body.pass)+"', '"+req.body.email+"')");
				res.send("Successfully added User: "+req.body.username, 200);
			}
		});
	}); 
});

app.post('/newgroup', function(req, res){
	var errors = new Array();
	if (!req.body.name) {
		errors.push("Name Required");
	}
	dbClient.query("SELECT * FROM `groups` WHERE name = '"+req.body.name+"'", function(err, rest, fields) {
		if (rest.length > 0) {
			errors.push("Name Required");
		} 
		if(errors.length > 0) {
			res.render('errors', {
				title: 'Error Registro', 
				error_array: errors 
			});
			return;
		}
		var mebersjoined = req.body.member;
		if (typeof req.body.member == "Array"){
			var mebersjoined = req.body.member.join(",");
		}
		dbClient.query("INSERT INTO `groups` (`name`, `members`) VALUES ('"+req.body.name+"', '"+mebersjoined+"')", function (err, rest, fields) {
			if (err) {
				throw err;
			}
			var confChanges = "Added Group: "+req.body.name;
			generateGitoliteConf(function (result) {
					console.log(result);
					fs.writeFile(config.gitolitepath +'/conf/gitolite.conf', result, function (err) {
						if (err) {
							console.log('nooooo');
							throw err;
						}
					console.log("Guardado Conf");
					exec('cd '+config.gitolitepath+'/ && git add conf/gitolite.conf', function (err, stdout, stderr) {
						if (err !== null) {
							console.log(err);
						}
						console.log("Agregado al repo");
						Gitolitecommitandpush(confChanges);
						res.send("Successfully added Group: "+req.body.name, 200);	
					});
				});
			});
		});
	});
});

app.post('/deletegroup', function(req, res){
	var groupid = req.body.group.replace("@", "");
	var querystr = "DELETE FROM `groups` WHERE `id` = '"+groupid+"'";
	dbClient.query(querystr, function(err, resq, fields){
		if (err){
			console.log(err);
			res.send("ERROR", 200);
			return;
		}
		var confChanges = "Deleted Group";
		generateGitoliteConf(function(result){
			fs.writeFile(config.gitolitepath +'/conf/gitolite.conf', result, function (err) {
		    	if (err) {
		    		console.log('nooooo');
		        	throw err;
		       	}
		        console.log("Generated new conf without the deleted group");
		        exec('cd '+config.gitolitepath+'/ && git add conf/gitolite.conf', function (err, stdout, stderr) {
		        if (err !== null) {
		        	console.log(err);
		        }
		        console.log("conf added to commit");
				res.send("Successfully deleted group: "+req.body.user, 200);
		        	Gitolitecommitandpush(confChanges)
		        });
		    });
	    });	
	});
});

app.post('/deleteuser', function(req, res){
	var querystr = "DELETE FROM `users` WHERE `username` = '"+req.body.user+"'";
	/*if (req.body.user.substr(0,1) == "@"){
		querystr = "DELETE FROM `groups` WHERE `id` = "+req.body.user.substr(1,req.body.user.length-1);
	}*/
	dbClient.query(querystr, function(err, resq, fields){
		if(err){
			console.log(err);
			res.send("Couldn't delete it", 200);
		} else{
			console.log("Deleted from database");
			fs.unlink(config.gitolitepath+'/keydir/'+req.body.user+'.pub', function(err){
				if (!err){
					var confChanges = "Deleted User: "+req.body.user;
					exec('cd '+config.gitolitepath+' && git rm keydir/'+req.body.user+'.pub', function(){
						if (err !== null) {
               				console.log(err);
           				}
           				console.log("Deleted pubkey and sent to commit");
						generateGitoliteConf(function(result){
							fs.writeFile(config.gitolitepath +'/conf/gitolite.conf', result, function (err) {
		       					if (err) {
		           					console.log('nooooo');
		           					throw err;
		       					}
		        				console.log("Generated new conf without the deleted user");
		        				exec('cd '+config.gitolitepath+'/ && git add conf/gitolite.conf', function (err, stdout, stderr) {
		           					if (err !== null) {
		               					console.log(err);
		           					}
		           					console.log("conf added to commit");
									res.send("Successfully deleted user: "+req.body.user, 200);
		           					Gitolitecommitandpush(confChanges)
		        				});
		    				});
						});
					});
				} else {
					throw err;
				}
			});
		}
	});
});
app.listen(6170);
console.log("Express server listening on port %d in %s mode", app.address().port, app.settings.env);